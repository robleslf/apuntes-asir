= Comandos ISO

== pwd 
En qu√© directorio estamos posicionados.

== clear 
Limpia pantalla.

== exit
Salir de la terminal.

== history
muestra el historial de comandos.

=== history -c
borra el historial de comandos.



== id 
Toda la informaci√≥n sobre nuestra cuenta: grupos, nombres y n√∫meros.

[EXAMPLE]
====
usuario=n√∫mero_de_grupo(nombre_de_grupo)
====

=== id -nu
Nombre de usuario; el par√°metro (los par√°metros van con gui√≥n) nu es "name user", y puede ir en diferente orden *-un*.

=== id -u 
N√∫mero de usuario.

=== id -g 
N√∫mero de grupo principal.

=== id -gn
Nombre del grupo principal.

* *groups:* Nos muestra todos los grupos a los que pertenece el usuario actual.

== uname
Muestra informaci√≥n sobre el sistema operativo. 
Nombre del sistema (Unix NAME). Se suele utilizar con par√°metros, es raro usarlo solo.

=== -n 
Nodo. Es el nombre del PC. 

=== -o 
Nombre completo del Sistema Operativo.

=== -p 
Procesador. Muestra la arquitectura del procesador, p.ej: x86_64.

=== -r 
Release; versi√≥n del kernell, n√∫cleo, del SO.

=== -a 
muestra todo (all). Muestra el nombre del kernell (Linux), el nombre del host, la 
versi√≥n del kernell, la arquitectura del hardware y la fecha y hora de compilaci√≥n del kernell.

___

image:assetsa/imgs/001_grafico.png[Gr√°fico 001]

___

== date 
Nos muestra la fecha/hora.

=== date | tee fichero.ext
Mostrar√° la fecha y la hora actual en la pantalla y, al mismo tiempo, guardar√° esa informaci√≥n en un archivo llamado "fichero.ext".

== bc 
Entras a la calculadora. 

- Ctrl+D (^D) para salir.

== man
Manual del sistema. Va seguido del comando del que quieres saber la ayuda.

- Por ejemplo, *man date* Ayuda del comando date.

== info 
Informaci√≥n. Se basa en el man, pero suele ser m√°s entendible. Es indistinto usar uno u otro, donde se encuentre mejor. Suele dar m√°s ejemplos el info.
Al igual que _man_, se usa seguido de un comando:

- Por ejemplo, *info date*

[NOTE]
Para salir, tanto de _man_ como de _info_, hay que pulsar la _q_ de _quit_.

== whatis [...] 
Nos dice para qu√© sirve un par√°metro, por ejemplo: *whatis pwd*.

== echo [...] 
Emite el mensaje que le pongas por pantalla.

== ls 
(Listar), nos muestra el contenido de donde estamos. Tiene una serie de colores (en Ubuntu al menos).

=== -a 
Nos muestra los ficheros y directorios, inclu√≠dos ocultos.

=== . 
Nos muestra lo del directorio actual, es lo mismo que no poner nada.

=== .. 
Nos muestra lo que hay en el directorio padre.

=== -A 
Lista los archivos y directorios en un directorio, excluyendo los directorios especiales " . " (punto) y " .. " (punto-punto). 

Estos dos directorios son referencias al directorio actual y al directorio padre, respectivamente, y se omiten en la salida cuando se utiliza ls -A. Muestra tambi√©n los ocultos. 

Vamos, resumiendo, muestra lo mismo que el *ls -a* pero sin las referencias al directorio padre y el directorio actual.
    
=== -l 
Listado largo, tiene la mayor√≠a de la informaci√≥n que estamos buscando: nombre, tama√±o de la carpeta, hora y fecha de creaci√≥n... Y el tipo de fichero que es (la _d_ es de directorio, el _._ un fichero oculto, la _ un fichero ordinario...) y los permisos (rwx), qui√©n es el propietario del fichero y cu√°l es el grupo primario (el grupo que sale es el grupo principal que era en el momento de la creaci√≥n).

[NOTE]
    El CHAR al principio del directorio en el *ls -l* hace referencia al tipo de archivo:
        
        d ‚Üí directorio

        - ‚Üí fichero ordinario

        l ‚Üí link

        c ‚Üí CHAR

        b ‚Üíficheros por bloque

        p ‚Üí pipe

        s ‚Üí socket


=== -1 
La lista la quiero en una columna; no existe el -2 xD. Obviamente si lo combinas con -l no hace falta porque ya lo saca en una columna, carece de sentido.

=== ls -d /ruta/al/directorio
El comando mostrar√° el nombre del directorio _/ruta/al/directorio_ en lugar de listar los archivos y subdirectorios que contiene.

=== ls / 
En este caso nos muestra lo que hay en la ra√≠z del sistema; se puede poner otro sitio en vez de _/_, por ejemplo *ls /home -l*.

=== -M* 
Que liste todo lo que empiece por M. Si buscamos directorios hay que hacer el siguiente comando.

=== -d M* 
Especifica que buscas un directorio la _-d_. Con la -d te muestra tanto directorios como archivos-

=== ls -ld M* > Musica.vacio 
Te crea el directorio que le pones detr√°s del _>_

=== ls -ld \*ca* 
Que muestre lo que empiece como sea, que contenga _ca_, y que acabe como sea, como si no hay nada m√°s del _ca_.

=== ls -ld *s > termina.s 
No lo mostrar√° por pantalla, porque le est√°s cambiando la salida al archivo que le mandas crear despu√©s del _>_.

=== ls -[DdEe]* 
Lista los elementos que empiecen con D, d, E o e. En el ejemplo se pone tanto min√∫scula como may√∫scula porque discrimina estas.

=== ls -d [{CHAR}-{CHAR}]*
Lista elementos que empiecen por los CHAR(S) dentro de un rango. Es sensible a may√∫sculas y min√∫sculas.
     
    ‚ñ™ Ejemplo: ls -d [A - E] ‚Üí Buscar√° todo lo que contenga desde una ‚ÄúA‚Äù hasta una ‚ÄúE‚Äù
    
    ‚ñ™ Ejemplo: ls -d [A - EI]* ‚Üí Buscar√° todo lo que acaba con una ‚ÄúA‚Äù hasta una ‚ÄúE‚Äù o acabe en una ‚ÄúI‚Äù


[NOTE]
Los par√°metros se pueden combinar; por ejemplo: *ls -la*

[NOTE]
La ruta y el par√°metro pueden ir uno delante del otro indistintamente: *ls .. -l* = *ls -l ..*


=== ls -ld \*[CHAR(S)-CHAR(S)]* 
Busca elementos que contengan caracteres de un rango determinado.

* Ejemplo: ls -ld *[0-9]*: busca elementos que contengan un caracter en el rango entre corchetes ambos inclusive ‚Üí lista todos los elementos que contengan 0, 1, 2, 3, 4, 5, 6, 7, 8 y/o 9, independientemente de donde est√©n los n√∫meros en el nombre del elemento.

=== ls -ld [*][.][?] 
Lista los elementos que despu√©s de un punto tengan determinado n√∫mero de caracteres, determinados por el n√∫mero de <?>.

=== ls -ld [^f]]* 
Lista los elementos que NO empiecen por _f_.

=== ls -ld {CHAR(S)}? 
Lista elementos que despu√©s del caracter contiene determinado n√∫mero de caracteres, determinados por el n√∫mero de <?>.
            
=== ls -ld *f*[0-9]* 
Lista los elementos que contengan un <f> y despu√©s, un n√∫mero de 0 a 9, ambos inclusive.

=== ls -r
Hace un listado en orden alfab√©tico inverso (Z-A)

=== ls -lR <directorio> 
R (de üîÅ recursividad) 
Ver todo el directorio y su contenido 	
        
=== ls -R
Registra todos los directorios de la ra√≠z. Los ordena en orden alfab√©tico
        ‚ó¶ 2> /dev/null: redirige la salida y descarta aquellos a los que no puede acceder, consider√°ndolos como errores y la salida va a /dev/null, es decir, la ‚Äúpapelera‚Äù
        ‚ó¶ ls -lR / 2> /dev/null: hace un listado recursivo del directorio ra√≠z (root), e indica que en caso de error, redirige a una salida

=== ls -id: muestra el inodo de un elemento
        ‚ó¶ para listar el inodo de los elementos dentro de un directorio, utilizamos los comodines
            ‚ñ™ ejemplo: ls -id *

[NOTE]
El inodo o i-nodo es un identificador √∫nico de un archivo o directorio, y es irrepetible. La √∫nica manera de que se repita es utilizando un enlace

== ; (Concatenaci√≥n de comandos)
Para concatenar comandos, utilizaremos [;]
    ‚Ä¢ Por ejemplo: date; pwd; ls > informe.txt ejecuta los tres comandos juntos, seguidos y de manera independiente, pero solo redirige el √∫ltimo como salida a un fichero, y mostrando el resultado de todo
    ‚Ä¢ Ejemplo 2: (date; pwd; ls) > informe.txt ejecuta los tres comandos de forma simult√°nea y redirige la salida de los tres juntos a un fichero.
	
== </>/>> (Redireccionamiento)
    ‚Ä¢ < redirecciona la entrada
    ‚Ä¢ > redirecciona la salida hacia un archivo, si este existe, lo sobreescribir√°, si no existe, lo crear√°.
    ‚Ä¢ >> redirecciona la salida, pero no sobreescribir√° el archivo existente, sino que se a√±adir√° al fichero al final. En caso de no existir el fichero, lo crear√°.

La mayor√≠a de estos se usan para editar ficheros con cat
 
== tee
    redirecciona la salida a un fichero y luego lo muestra por pantalla
        ‚ó¶ tee - a fichero.extensi√≥n: redirecciona la salida, muestra por pantalla y a√±ade contenido al fichero
            ‚ñ™ Ejemplo: date | tee -a informe.txt crea el informe.txt y le a√±ade informaci√≥n resultante del comando date



== cat nombre.fichero 
Visualiza contenidos de un fichero (solo muestra el contenido)
        ‚ó¶ para crear un fichero, de manera interactiva, redireccionamos la salida del comando a un nuevo	fichero
            ‚ñ™ Ejemplo: cat > ejemplo.txt ‚Üí Despu√©s Ctrl + D para terminar

=== cat -n
Enumera las l√≠neas de un fichero
        ‚ñ™ Si nuestro fichero contiene los n√∫meros rojo, azul y blanco uno en cada l√≠nea, visualizamos 1	rojo, 2 azul, 3 amarillo...
        ‚ó¶ cat {fichero1} {fichero2} >> {fichero3}: une dos ficheros, uno a√±adido al final del otro

== tac
Visualizar un fichero en orden inverso.
            ‚ñ™ Si nuestro fichero contiene los n√∫meros 1, 2 y 3, uno en cada l√≠nea, visualizamos 3, 2 y 1.

[NOTE]
No se puede usar -n con el tac.

== history
Muestra un historial de los comandos utilizados hasta el momento

=== history -c 
Elimina todas las entradas del historial (_c_ de clean).

=== history {NUMERO} 
Muestra los √∫ltimos comandos del historial, el n√∫mero de entradas es el establecido por el {NUMERO}
        ‚ñ™ Ejemplo: history 10: muestra los 10 √∫ltimos comandos utilizados.

=== history !{N√öMERO}
Vuelve a realizar el comando con este n√∫mero en el historial.

== more 
Permite visualizar un fichero como listado largo, permitiendo saltar l√≠neas o p√°ginas enteras.

=== more +3 fichero.extensi√≥n
Muestra el fichero a partir de la l√≠nea 3, inclu√≠da.
Se puede poner cualquier n√∫mero.


=== <comando> | more 
Para paginar un listado.

==== history | more 
Muestra el listado del historial de comandos en forma paginada.
Al pulsar [intro] vamos a una l√≠nea m√°s abajo y  al pulsar [espacio] nos movemos una p√°gina entera, Para salir pulsamos [Q]

== less 
Permite visualizar un fichero paginado pudiendo ir hacia delante o hacia atr√°s en las p√°ginas.

=== <comando> | less 
Para paginar un listado. Permite movernos hacia atr√°s.

* *cat nombre.fichero:* Visualizamos el contenido de un fichero ordinario.
* *cat > nombre.fichero:* Crear un fichero de forma interactiva; le vas a poner datos y los va guardando en el fichero; cuando quieras acabar, Ctrl+D.

___

Estos comandos est√°n repetidos, no los borro por si acaso.


=== ls -l d-uno
Mostrar el contendio del directorio d-uno

=== ls -l d_uno/d_dos
Mostrar el contenido de d_dos.

=== ls -R / 2>/dev/null
Que haga un listado recursivo desde la ra√≠z (/)
El 1 es para que muestre por pantalla, no es necesario porque lo pone por defecto. Pero el 2 es de error, y lo de null es papelera, para que se deshaga del error y lo mande a la papelera. 
Si quiero hacer un listado recursivo a partir del directorio actual, vale con no ponerle nada, o sino: *ls -R . 2>/dev/null*; y si quieres desde la ra√≠z *ls -R / 2>/dev/null*

Con la -R va entrando en todos los subdirectorios desde la ra√≠z y dici√©ndote qu√© hay en cada uno.


=== ls -r 
La r min√∫scula es de reverse, y va a ir de la Z a la A. 


[NOTE]
No confundir -R con -r, la primera es recursividad, la segunda es reverse, de la A a la Z-

___


== rmdir d_tres
Borra el directorio d_tres, pero tiene que estar vac√≠o. Dar√° fallo si tiene contenido.

== rm -r d_uno 
Elimina el directorio aunque tenga contenido. Aqu√≠ la -r es remove, no reverse. 

___

Los siguientes vuelven a ser comando repetidos

== cat -n colores.txt 
El - n enumera las l√≠neas del archivo.


== more colores.txt 
Nos permite ver un fichero por dentro a partir de cierta l√≠nea; por ejemplo, *more +3* muestra a partir de la l√≠nea 3, esta inclu√≠da.

== less colores.txt
Va igual que el more pero cambia algo que no se que es.

== ls -1 / | more +3
Vemos el listado a partir de la l√≠nea 3.

___

== cp colores.txt color.txt 
Copiar un archivo _colores.txt_ y guardarlo con el nombre _color.txt_.

=== cp colores.txt cinco/
Que haga una copiar de colores.txt en el directorio cinco/ 
Formato ‚Üí *cp origen destino*
La "/" es opcional, va a entender que es un directorio aunque no se la pongas.

== mv colores.txt lista.color.txt 
Renombrar el archivo colores.txt a lista.color.txt. 
Con mover no generas nada, simplemente cambias el nombre del fichero. 
*mv* tambi√©n renombra directorios: *mv seis dire*

=== mv planetas.txt dire/ 
*mv* tambi√©n sirve para mover, aqu√≠ est√° moviendo el archivo planetas.txt al directorio dire/.

=== mv color.txt siete/color.siete.txt 
No solo lo mueve, sino que lo renombra a la vez.

=== mv *.txt ..
Cuando usemos comodines como mover todo lo que termine en .txt, puede dar problemas, sobre todo si en vez de en el origen como en el ejemplo, usamos el comod√≠n en el destino. Verificar siempre con _ls_. Por ejemplo, si quiero coger todos los ficheros .txt y renombrarlos a .doc (*mv *.txt *.doc*) nos va a dar error, se piensa que *.doc es un directorio

=== cp ~/{c1.txt,c2.txt,lscolor.txt} .
Le estamos pidiendo que con una ruta absoluta vaya a home, y coja los tres ficheros que hay entre llaves y los copie aqu√≠ (.) OJO NO PONER ESPACIOS DESPU√âS DE LAS COMAS.


=== cp ../c1.txt ../c2.txt ../COLOR.txt ocho/
Es lo mismo, que copie los fichero del directorio padre (vamos, realmente el archivo est√° en el directorio donde estamos xd) y los copie a ocho/. Las rutas de origen pueden ser todas las que quieras, la que tenga cada archivo que quieres copiar, pero el destino tiene que ser el mismo para todos, solo puede ser uno.

== touch 
Crea fichero vac√≠o; puede crear varios a la vez: *touch iso.txt fol.txt bases.txt*; si quiero crearlos en diferentes rutas, se especifica en cada fichero: *touch ../xbd.txt /../apuntes/fundamentos.adoc*.


== mkdir -p facturacion/compras/{C_2020,C_2021} 
La opci√≥n -p le indica a mkdir que cree todos los directorios necesarios en el camino especificado, incluso si los directorios padres a√∫n no existen. Sin la opci√≥n -p, mkdir podr√≠a dar un error si intenta crear un directorio dentro de un camino que a√∫n no existe.
Si todos los directorios en la ruta especificada ya existen, entonces puedes omitir la opci√≥n -p. La opci√≥n -p es √∫til para asegurarse de que todos los directorios en el camino se creen, pero si ya existen, no causar√° ning√∫n problema.


== touch facturacion/compras/C_2020/{ene_2020.txt,feb_2020.txt,mazo_2020.txt}
Crear tres archivo a la vez en un directorio (destino{ficheros}); ojo a no poner espacio despu√©s de las comas.

[NOTE]
Ojo a no poner espacios en blanco despu√©s de las comas en lo que va entre llaves {}


== file
Te dice el tipo de archivo que es.

=== file *
Te dice qu√© tipo de archivos son todos los del directorio actual.

=== file archivo.txt
Te dice qu√© tipo de archivo es el que t√∫ le pones.


___

== Cambiar fecha a un archivo

* *ls -l colores.txt:* puedes ver por ah√≠ la fecha.
* *touch colores.txt:* haces un touch al fichero que ya existe.
* *ls -l colores.txt:* ahora la fecha es otra.

=== touch -c colores.txt 
As√≠ es mejor cambiar la fecha, porque como no exista el archivo y no le pongas el -c, te lo crea; en caso de que no exista, con el -c no crea nada.

=== touch -t 12311200 colores.txt
Cambias la fecha al archivo, el formato de la fecha es mmddhhmm -mes, d√≠a, hora, minuto-). Se puede a√±adir a√±o al principio (touch -t 2004011200 colores.txt pondr√≠a el a√±o 2020 -solo se pone el 20-), sino asume que es el actual; si no pones hora suele poner las 12pm.

La -t es de _timestamp_.

El comando touch en sistemas Unix y Linux permite especificar una marca de tiempo espec√≠fica utilizando la opci√≥n -t. Puedes usar el formato [[CC]YY]MMDDhhmm[.ss], donde:

CC es el primer componente del a√±o (siglo).
YY es el segundo componente del a√±o (dos √∫ltimos d√≠gitos).
MM es el mes.
DD es el d√≠a.
hh es la hora.
mm es el minuto.
.ss es opcional y representa los segundos.
Por ejemplo:

[source, bash]
----
touch -t 202311152030.00 colores.txt
----

=== touch -r color.txt colores.txt 
La -r es de referencia, color.txt es el archivo al que hace esa referencia, y colores.txt el archivo al que va dirigido; as√≠, la fecha y hora del archivo color.txt ser√° tambi√©n ahora la fecha de colores.txt.
Funciona tambi√©n con directorios, eh.

___

== Enlaces

Tenemos dos tipos de enlaces:

=== Simb√≥licos

Lo que en Windows son los accesos directos; acceso directo a un fichero o a un directorio. Trabajan sobre:
    - Ficheros
    - Directorios

[source,bash]
----
ln -s facturacion/compras/c_2020/ enlace_c_2020
----

Primero se pone la ruta donde va a dirigir el link, y despu√©s el nombre que queramos.

Ahora cuando quiera cambiar a ese directorio, usaremos cd con el enlace:

[source, bash]
----
cd enlace_c_2020
----

Y al hacer *pwd* veremos que nos ha llevado a la ruta del enlace.

Si en vez de a un directorio el enlace es a un fichero, un cd nos dar√° error porque no se le hace cd a un fichero ordinario, pero se podr√≠a hacer un cat al enlace, por ejemplo.

Si queremos borrar los archivos que hay en esa ubicaci√≥n.

[source, bash]
----
rm enlace_c_2020/*
----

Y nos eliminar√° todos los archivos, pero nos dejar√° el accesos directo, solo que ahora es inservible.

Si adem√°s eliminas el directorio de la ruta, cuando haces un ls -l el enlace aparece en rojo y negro, porque es inservible; por eso habr√° que eliminar el enlace.

[source, bash]
----
rm enlace_c_2020/
----

Se elimina normal porque para Linux es un fichero m√°s.


=== hard link 

Solo trabajan sobre *FICHEROS*.

[source, bash]
----
ls -id *
----

El -i es de inodo (y la -d de directorio), es como el DNI de una entrada, un n√∫mero que no se repite. Si sacamos cada inodo de cada entrada. No es solo un n√∫mero, contiene una serie de informaci√≥n donde guarda ese n√∫mero de inodo, el nombre del fichero o directorio, el tipo, cu√°ndo fue creado, por qui√©n. cuando se modific√≥ por √∫ltima vez, cu√°ndo se accedi√≥ por √∫ltima vez en solo lectura...

En el caso de los enlaces duros, los inodos se repiten, es la √∫nica excepci√≥n que tenemos, el inodo es por esencia irrepetible.

En Windows esto no existe.

La idea es la siguiente, crear un fichero y todo el mundo accediendo a √©l, y modificando. Si uno lo modifica, entra la modificaci√≥n a todos. Todos ven las modificaciones, porque el fichero es uno, aunque tengamos cada uno el fichero en su propia carpeta personal.

* *ls -lih:* vas a ver los n√∫meros de inodos y los KB que ocupan. La -h es de humanizar, para que te lo muestre en una medida que entiendas.

Para crear un enlace duro:

[source, bash]
----
ln /home/asir1/colores.txt colores.txt
----

El fichero est√° en el sistema una sola vez, no repetido tantas veces como ln se hagan. 

___

== wc datos.txt
El comando wc (word count) en Unix y sistemas similares se utiliza para contar palabras, l√≠neas y caracteres en un archivo. Si ejecutas el comando wc con el nombre de un archivo, proporcionar√° tres valores por defecto: el n√∫mero de l√≠neas, el n√∫mero de palabras y el n√∫mero de caracteres en ese archivo.

=== wc -l datos.txt
Cuenta las l√≠neas que tiene el fichero datos.txt.

=== wc -w datos.txt
Cuenta las palabras del fichero datos.txt; solo cuenta las palabras por espacio, es decir, si tenemos maria:blanco:negreira:1500 solo lo toma como una palabra.

=== wc -c datos.txt
Cuenta los caracteres del fichero datos.txt.

** **wc -L datos.txt:* 
Nos dice cu√°ntos caracteres tiene la l√≠nea m√°s larga del fichero datos.txt.

[NOTE]
Estos par√°metros se pueden combinar, por ejemplo, si quiero saber el n√∫mero de caracteres que tiene la l√≠nea m√°s larga, y a la vez el n√∫mero de caracteres del archivo, usar√≠a *wc -L -c datos.txt*.

=== wc como filtro
wc puede usarse, adem√°s de como comando, como filtro.

* *ls / | wc* 

* *ls / | wc -l*

Dos m√©todos para ver el n√∫mero de l√≠neas de un fichero:

* Como comando: *wc -l reporte.txt*

* Como filtro: *cat reporte.txt | wc -l*

Ambas hacen exactamente lo mismo.

Y si uso el *tac* para que las cuente al rev√©s lo mismo, da igual que las cuente de un lado o de otro que son las mismas.

=== wc -l reporte.txt datos.txt
Me cuenta las l√≠neas de los dos ficheros y adem√°s me hace la suma.

=== wc -lc /etc/*
dar√° una salida que incluye el conteo de l√≠neas y caracteres para cada archivo individual en ese directorio y sus subdirectorios, as√≠ como el total acumulado al final. Muchos son directorios por lo que dar√° errores.

=== wc -lc /etc/* 2>/dev/null:
As√≠, todos los errores no se muestran.

=== Paginarlo
La salida es largu√≠sima, por lo que podemos usar un filtro para paginarla.

* wc -lc /etc/* 2>/dev/null | less:

* wc -lc /etc/* 2>/dev/null | more:


___

== Unir varios ficheros

Tengo dos ficheros: datos.txt y reporte:

* *cat datos.txt reporte > reporte.datos:* se a√±ade el segundo debajo del primero en un nuevo fichero llamado reporte.datos. El orden en el que se escriben los ficheros es importante.

* *cat dichos_3.txt >> dichos.txt:* as√≠ unes el fichero dichos_3.txt con el ficheros dichos.txt; queda el fichero dichos.txt con su contenido original y al final se le ha a√±adido el contenido del fichero dichos.3.txt.

[NOTE]
Con el > lo que haces es meter el contenido en el fichero tal cual, es decir, vas a sobreescribir el contenido del fichero de destino (a no ser que no exista, entonces crea uno nuevo y da un poco igual); con el >> lo que haces es a√±adir el nuevo contenido al fichero de destino, es decir, el fichero de destino queda igual que estaba y adem√°s se le a√±aden al final nuevo contenido.
___

== cat -n reporte.datos
Enumera cada una de las filas, es solo visual y no modifica el fichero.

== head -5 reporte.datos
Quiero ver, desde el top (head, cabecera) las cinco primeras l√≠neas, se puede poner cualquier n√∫mero, empieza desde la cabecera y va cogiendo las cinco primeras l√≠neas. Si no pongo ning√∫n par√°metro va a mostrar 10 l√≠neas.

[NOTE]
---
El head funciona como comando y como filtro: cat reporte.datos | head -3
---

== tail -2 reporte.datos
Funciona al rev√©s que el head, desde abajo. Muestra tambi√©n 10 por defecto si no le indicas par√°metro.


=== cat -n reporte.datos | head -5 | tail -2
Si queremos que solo nos muestre las l√≠neas 4 y 5, le pedimos dos filtros a la vez: el del head nos muestra hasta la l√≠nea 5, y ahora el tail nos muestra solo la 5 y la 4 que son las dos primeras desde abajo.

=== tail +4 reporte.datos 
En vez de poner un - pongo el + para decirle que se posicione en la l√≠nea 4; va a mostrar *desde* l√≠nea 4; hace lo mismo como filtro *cat -n reporte.datos | tail +4*; si adem√°s se le a√±ade un filtro head -2 te coge las dos primeras l√≠neas de las que filtr√≥. Quedar√≠a *cat -n reporte.datos | tail +4 | head -2* 

=== head -1 * 
Te muestra la primera l√≠nea de todos los ficheros que hay en el directorio actual. Puede usarse cualquier comod√≠n, por ejemplo, head -1 rep*; con los directorios dar√° error, as√≠ que se le puede a√±adir esto: _head -1 * 2>/dev/null_


___

Lo normal en Linux para separar campos son los dos puntos:

_maria:blanco:negreira:1500_

Si tengo un fichero con varios registros como el anterior, y quisiera guardar en otro fichero todos los nombres de la primera columna (maria en el registro de ejemplo), usar√≠amos el comando _cut_ para cortar la columna.

== cut -d: -f1 datos.txt > usuarios.txt 
La -d es el delimitador, donde va a cortar, en este caso le indicamos que un campo termina con los dos puntos; la -f es de field, campo, y le decimos que queremos que saque el primer campo (maria). 

=== cut -d: -f2 datos.txt | tee colorin.txt
Aqu√≠ usamos el tee; el -f2 solo coge el campo 2 eh, no el 1 y el 2.

=== cut -d: -f1,4 datos.txt 
as√≠ es solo visual, no lo estamos guardando en ning√∫n sitio, lo que si en el par√°metro -f le estamos diciendo que queremos dos campos, el 1 y el 4.

=== cut -d: -f1-3 datos.txt
Con el gui√≥n en vez de la coma, lo que indicas es un rango, coges de la columna 1 a la 3.

== cut tambi√©n funciona como filtro:

=== ls -l | cut -d " " -f1 
Aqu√≠ le pido un listado largo, y le filtro con el delimitador espacio y columna 1. Ojo con dejar espacio entre la d y la comilla de apertura, no pegarlos nunca. (En este caso va a pasar una cosa no deseada, y es que algunas columnas del listado tienen dos espacios de separaci√≥n entre ellas, por ejemplo cuando en una columna hay n√∫meros, algunos son de 3 cifras y otros de 2, por lo que los de 2 tienen un espacio en blanco de m√°s, y cuenta otra columna de m√°s).


=== ls -l | tee nombre.fichero
Muestra el ls por pantalla y a la vez lo guarda en el archivo nombre.fichero.

___
== sort datos.txt
Ordena el fichero, sin ning√∫n par√°metro simplemente toma el primera caracter de cada registro y lo ordena.

=== sort -t: -k2 datos.txt 
Aqu√≠ la -t es el delimitador, entonces le estamos diciendo que los dos puntos son el delimitador, la -k es de clave, queremos la segunda clave (el segundo campo); entonces ordena en funci√≥n de la segunda columna.

[NOTE]
Mucho cuidado con confundir los delimitadores y campos/claves entre cut y sort; en cut el delimitador es -d de delimitador, mientras que en sort es -t de separator; en cut el campo es -f de field, en sort es -k de key.

=== sort -t: -k4 -n datos.txt
Para ordenar por campos num√©ricos, lo que har√≠a normalmente es ordenar por primer caracter, y tomar√≠a primero el 1100 antes que un 990, por el 1 y el 9. Por eso hay que a√±adir el -n de num√©rico.

=== sort-t: -k4 -nr datos.txt
La -r es de reverse, lo ordenar√° de mayor a menor.

___

sort puede actuar como filtro:

=== cut -d: -f3 datos.txt | sort

=== cut -d: -f3 datos.txt | sort | uniq
As√≠ no habr√° datos repetidos.

=== cut -d: -f3 datos.txt | sort | uniq -u 
Con -u nos muestra solo datos que no se repiten.

=== cut -d: -f3 datos.txt | sort | uniq -c 
cuenta cu√°ntas veces se repite cada resultado.

[NOTE]
Siempre que usemos _unique_ es importante usar el _sort_ antes, porque lo que est√° comparando el _unique_ es la fila de arriba con la de abajo, y si no est√°n ordenados, va a mostrar repetidos:
ames
ames
ames
negreira
santiago
santiago
As√≠ comparar√≠a santiago con santiago y ames con ames con ames. Si no est√° ordenado,  no los compara.


=== cut -d: -f3 datos.txt | sort | uniq -c | cut -d " " -f2 
As√≠ no nos muestra la columna que queremos porque hay varios espacios antes y toma m√°s columnas de las que queremos.

=== cut -d: -f3 datos.txt | sort | uniq -c | cut -d " " -f8 
As√≠ s√≠, porque est√° en la columna 8 realemnte con lo de los espacios.

=== cut -d: -f3 datos.txt | sort | uniq -c | cut -c 9-20 
As√≠ le pedimos que coja a partir del car√°cter 8 y coja hasta el 20, en vez de usar delimitadores. 

=== cut -d: -f3 datos.txt | sort | uniq -c | cut -c 9-20 | tee ciudades.txt
As√≠ adem√°s lo guardamos en un fichero ciudades.txt.

=== ls -l | cut -d " " -f3 | tail +2 | sort | uniq -c | tee usuarios2.txt: 
me sale cu√°ntos usuarios diferentes hay en el listado y cu√°ntas veces se repiten.

___

== cut -d: -f1 datos.txt > estado.civil
Cortamos la columna que queremos y la guardamos en un fichero.


== paste -d: datos.2.txt estado.civil | tee datos.3.txt
Si no lo guardas, el paste es solo visual. 
Para usar el paste lo mejor es crear un archivo temp antes con lo que queremos pegar.
El -d le pones tu el que quieras para que cuando lo pegue, use ese delimitador.


=== cut -d: -f4 datos.3.txt | sort -n -r | head -1
=== cut -d: -f4 datos.3.txt | sort -n | tail -1

Ambos comandos nos devolver√≠an lo mismo, en uno usamos reversa y otro no, as√≠ que filtramos el primero por el principio o por el final dependiendo.


[NOTE]
_cut_ trabaja como comando y como filtro.

cut -d: -f5 datos.3.txt | sort | uniq -c | head -2 | tail -1



== tr [A-Z] [a-z] < datos3.txt > datos.min.txt
tr es un traductor; todo lo que est√° en may√∫sculas lo ponga en min√∫sculas. Necesita obligatoriamente un redireccionamiento de ENTRADA (<); 

=== tr ":" "*" < datos.3.txt 
Que cambie todos los : a *. Aqu√≠ es solo visualmente el cambio.

=== tr [A-Z] [a-z] < datos.3.txt | tr ":" "*"
Doble traducci√≥n, no hace falta poner otra vez el archivo.


Tambi√©n funciona como filtro:

=== cat datos.3.txt | tr [A-Z] X 
Que todas las may√∫sculas las cambie por una X.

=== cat | tr -d [A-Z] 
El -d es de delete, y borrar√° todos los caract√©res que est√©n en may√∫scula.

[NOTE]
El archivo de entrada y salida no puede ser el mismo, porque entonces habr√≠a un bucle ah√≠ que no funcionar√≠a, queda el archivo en blanco.

___

== ls -l | tr -d ' ' | cut -d ' ' -f6 
Aqu√≠ al quitar los espacios nos queda solo una columna.

=== ls -l | tr -s ' ' | cut -d ' ' -f6
Aqu√≠ el -s nos quita solo los espacios repetidos, que es lo que necesitamos justo para esto.
La -s es de squeezing y es la que se encarga de eliminar repeticiones de caracteres

=== ls -l | tr -s ' ' | cut -d ' ' -f6 | sort | uniq -c 
Aqu√≠ nos dir√≠a cada mes y cu√°ntos salen por cada mes.

=== tr -c [a-z] " " < prueba
El -c es de contrario, va a reemplazar todo lo que no sea min√∫sculas de la a-z por un espacio en blanco. Lo contrario no son solo las may√∫sculas, tambi√©n n√∫meros, signos de puntuaci√≥n... cualquier caracter que no est√© entre a-z.

___

== uname -v 
Muesta la fecha de la √∫ltima compilaci√≥n del kernell.

___

== grep blanca datos 
Nos va a permitir buscar palabras en ficheros; pueden ser palabras enteras, partes de palabras... El orden es _grep ‚Üí lo que busco ‚Üí d√≥nde lo busco_.
    
=== grep bla datos 
En este caso nos devolver√≠a tanto blanca, como blanco.
    
Discrimina entre MAY y min, si tengo MARIA en un fichero, pero busco grep maria datos, no nos lo encuentra. Por eso:

=== grep -i maria datos 
-i de ignore-case, va a darle igual ahora si son MAY. o min.
    
=== grep -i maria datos datos.txt datos.2.txt 
Puedes buscar en varios ficheros a la vez. En la salida de la terminal va a mostrar el nombre del fichero donde aparece y la l√≠nea donde aparece en ese fichero.

=== grep -i maria datos*
aqu√≠ nos trae lo mismo que el anterior, pero como usamos el comod√≠n no hace falta escribir los tres archivos, ya entiende que est√°s buscando en todos los ficheros que comiencen por _datos_.

=== grep -i "Juan Carlos" dat*
En caso de que lo que busquemos tenga espacio en blanco, es OBLIGATORIO meterlo entre comillas, porque si no va a entender que lo que va despues del espacio en blanco es el archivo.

=== grep -ic maria dat*
El -c es un contador, entonces nos dice las ocurrencias, es decir, cu√°ntas veces aparece el texto "maria" en cada fichero. La terminal devolver√≠a algo similar a esto:
                datos:1
                datos.2.txt:1
                datos.4.txt:0
                datos.min.txt:1
                datos.txt:1

=== grep -icv ia * 
Con el -v de invert-match hace lo contrario, cuenta las l√≠neas donde NO aparece.    
    
=== grep -in santiago datos 
El -n n√∫mera la l√≠nea en la que est√° lo que busco.

___

Tambi√©n funciona como filtro el grep

== ls | grep -iA 1 os 
La -A es de after, y lo que hace es traer lo que buscas con el grep y, adem√°s, una l√≠nea despu√©s. El 1 puede ser cualquier n√∫mero, y entonces ser√≠an las n l√≠neas anteriores.

=== ls | grep -iB 1 os 
La -B es de before, y lo que hace es traer lo que buscas con el grep y, adem√°s, una l√≠nea anterior.

=== ls | grep -iC 1 os
La -C es lo que hace es traer lo que buscas con el grep y, adem√°s, una l√≠nea despu√©s y una l√≠nea antes. La -C es por A, B y C.

=== grep -in ^a color.txt: busca las l√≠neas que comiencen por a. Es la l√≠nea, no la palabra.

grep -in ^a..l$ color.txt: busca las l√≠neas que comiencen por a, contengan 2 car√°cteres y finalicen con l.

[NOTE]
^ Para indicar el comienzo.
. Para indicar cualquier caracter.
$ Para indicar el final.
* Para indicar un n√∫mero indeterminado de caracteres.

=== grep -in ^m..*o$ 
el asterisco es para indicar que despu√©s de los dos caracteres que siguen a la m, vienen m√°s caracteres, pero no se cu√°ntos son.
Es aconsejable poner entre "" la palabra que buscamos cuando escribimos caracteres especiales como *, en algunas terminales podr√≠a dar error si no.

=== grep -in ^m.*ia datos
Luego puedes poner t√∫ las combinaciones que necesites.

=== ls | grep [0-9] 
Buscamos todas las entradas que contengan un n√∫mero en el nombre.

ls | grep -i s[0-9]: delante del n√∫mero tiene que haber una s.

ls | grep -i ^[ce]......: la palabra que busco empieza o por c o por e, y luego tiene tantos caract√©res como puntos como m√≠nimo. Es la longitud m√≠nima lo que le indicas, luego puede ser mayor lo que te devuelva.

    ls | grep [24]: busco una entrada que contenga o el 2 o el 4.

[NOTE]
Cuando escribo algo entre los corchetes se lee de forma individual.

    ls | grep 24: si quisiese buscar un 24 lo pondr√≠a as√≠.

    ls | grep ^[a-fA-F]: que empiece por algo que sea de la "a" a la "f" o de la "A" a la "F". En este caso es v√°lido tambi√©n ls | grep -i [a-f]

    ls | grep -i [aeiou]$: que termine en vocal. Que ser√≠a lo mismo que ls | grep [aeiouAEIOU]$

    ls | grep -i [aeiou]...$: empezando por detr√°s, el cuarto es una vocal.

    ls | grep -i [aeiou][aeiou]: contiene dos vocales juntas, en cualquier posici√≥n.

    ls | grep -i [aeiou][aeiou]*: una vocal y la segunda puede que no aparezca.

    ls | grep -i [aeiou][aeiou][aeiou]*: dos vocales obligatorias y la tercera puede que no aparezca.

    La que est√° pegada al asterisco es opcional, puede que no aparezca ninguna vez.

    ls | grep -i ^[^a-e]: que NO empiece por ninguna letra de la a a la e.


    Dentro de los corchetes, el circunflejo ES NEGACI√ìN
    

    ls -a | grep "^\.": el punto hay que escaparlo para que no interprete que es un caracter cualquiera, sino que es un punto lo que buscamos.  SIEMPRE que escapemos algo, hay que meterlo entre comillas.

    ls -a | grep "^[^\.]": que no empiecen por punto

    ls | grep -i "\(tos\|tad\)": estoy buscando que tenga tos, o que tenga tad; el | no es un filtro, es un "o", por lo que hay que escaparlo; adem√°s hay que meterlo entre par√©ntesis para que sepa que es lo que buscamos, lo que pasa que hay que escapar tambi√©n estos par√©ntesis, y debemos meterlo entre comillas porque est√° escapado; puede contener ambas, tanto tos como tad.


___

grep asir1 /etc/passwd: con esto nos trae la l√≠nea que queremos de nuestro usuario.
grep -on asir1 /etc/passwd: nos dice en qu√© l√≠nea aparece asir1.
grep asir1 /etc/passwd | cut -d: -f7: con este filtro sabremos con qu√© shell estamos trabajando.

passwd: cambia la contrase√±a

ls -l /etc/passwd
ls -l /etc/group
ls -l /etc/shadow: aqu√≠, al contrario que en los anteriores, nos dice que pertenece al grupo shadow. Adem√°s tiene otros permisos.

los tres permisos son escritura (w), lectura (r) y   (x).

Los tres primeros caract√©res pertenecen al propietario; los tres siguientes al grupo; los √∫ltimos a otros.

umask: visualizar la m√°scara que tenemos. 

La m√°scara se calcula sobre los ficheros:

rw-rw-rw-
110110110
 6  6  6

Ese es el valor m√°s alto que se le puede dar a un fichero, 666 (para directorio es 777).

rw-r-----
110100000
 6  4  0

Ahora al valor m√°s alto le restamos el nuestro, y ese es nuestro n√∫mero de m√°scara (026). 

[NOTE]
Una m√°scara SIEMPRE es un n√∫mero par.


umask 026: cambiamos a esa m√°scara.
touch abc.txt: creamos el archivo abc.txt
ls -l : vemos los permisos de abc.txt ‚Üí -rw-r-----


mkdir adir: creamos un directorio
ls -ld adir/: vemos los permisos de adir ‚Üí drwxr-x--x


Tan pronto cerremos la terminal, la m√°scara se borra, porque la m√°scara est√° en un . fichero de configuraci√≥n.

En caso de querer dejarla fija:


ls -la: vemos ficheros como el .bash_history, que es donde se guarda el historial de comandos para cuando usemos el comando history. .bashrc y .profile guardan tipo de letra, color de fondo de la terminal...

less .bashrc ‚Üí los valores en may√∫scula con un = despu√©s son las variables del sistema. Cuando hay # significa comentario.

vi profile ‚Üí vamos hasta la m√°scara, descomentamos la l√≠nea donde est√° la m√°scara, la modificamos por 026 y guardamos con :wq. 

exit

abrimos de nuevo; y verificamos:

touch abcd.txt
ls -l abcd.txt: los permisos son -rw-rw-r--

chmod: cambio en los permisos.

Hay dos modos de cambiar los permisos, con octal o con forma simb√≥lica.

chmod g+w,o-w dos.txt: le agregas permiso de escritura y le quitas el de escritura.

imaginando un fichero con los permisos r--r----- en el que vemos los permisos, podr√≠a hacerse con el modo octal:

chmod 660 dos.txt

chmod 770 dir: esto es cambiar permisos a un directorio con modo octal.

chmod -R 660 dir/*: para los directorios (para los DIRECTORIOS) tengo una recursiva, -R. Cambia todos los permisos de lo que contiene el directorio.

___

== /bin/su

En bin est√°n los comandos, el comando su se utiliza para cambiar de cuentas de usuario.

En permisos de este comando aparece una "s", son los permisos especiales, vienen por defecto.
En vez de _rwx_, tienen _sst_.

En este caso la "s" la tiene el usuario propietario, es un *permiso de sustituci√≥n*; en ese fichero, por unos segundos, va a sustituir al root, porque necesita hacer una comprobaci√≥n en el fichero "shadow", por lo que por unos segundos hace esa lectura en ese fichero para comprobar que la contrase√±a es correcta.

Mirar diferencia entre s y S.

== /tmp

Este es el directorio temporal. Cada app que abrimos crea ficheros temporales, que al cerrar el programa, se destruyen. Si guardamos cosas en este directorio, al reiniciar el sistema, se borran. Tiene todos los permisos y adem√°s, en la √∫ltima posici√≥n, tiene una "t".

Mirar diferencia entre t y T.

La t es lo que se conoce como sticky bit.
BUscar qu√© es.

Limita las escrituras, puede ser sobre fichero o directorio, y significa que pueden modificar pero no eliminar.

Es √∫til por ejemplo si compartes una carpeta con un grupo, para que puedan editarlo pero no lo eliminen.

___

Si est√°n en may√∫scula es que por debajo no hay permisos de ejecuci√≥n, si est√°n en min√∫scula, es que s√≠.


sst 
ugo (usuario, grupo, otro)

A√±adir permisos ser√≠a:

chmod u+s nombre.txt ‚Üí para el usuario
chmod g+s nombre.txt ‚Üí para el grupo
chmod o+t nombre.txt ‚Üí para otros

y todos juntos:

chmod u+s,g+s,o+t nombre.txt


chmod o+w,+t nombre.txt: a√±ades los dos permisos a otro

https://www.ionos.es/digitalguide/servidores/know-how/asignacion-de-permisos-de-acceso-con-chmod/


___
comando cuando estamos conectados (lo de remmina)

w: de who, muestra qui√©n est√° conectado

tenemos tambien el who

who -T: el signo + o - nos muestra qu√© terminales pueden recibir mensajes con el wall; las que estan con + son las que si

who -q: cu√°ntos usuarios est√°n conectados a la terminal.

who | grep pepito: comprobar si pepito est√° conectado.

who | grep ^a: comprobar los usuarios conectados que empiezan por a.

who | grep pts/7: qu√© usuario est√° en la pts 7

who | grep 192.168.1.42. ver qui√©n est√° conectado con esa IP.

last -2: los dos √∫ltimos en conectarse. Puede ponerse el n¬∫ que se quiera.

wall: comando para mandar un mensaje a todos

mesg: si sale _y_, es que s√≠ puede recibir interrupciones del wall; 

mesg n: apagamos el wall para que no me lleguen mensajes del wall

mesg y: encendemos para poder recibir mensajes

mail: la primera vez puede salir que no tengo correo

mail nombredeusuario: enviar un mail a alguien; para enviar es control+d

la _q_ para salir del mail

ls -l /home: la configuraci√≥n aqu√≠ es distinta, est√°n las personas agrupadas por letra, salvo la cuenta principal que est√° aparte.

cd /home/asir1: permiso denegado

192.168.1.90 ‚Üí nada esto no es para estudiar es solo una nota

tty: ver donde est√° mi pseudoterminal, la m√≠a es la 17.

whoami: qui√©n soy o con qu√© nombre me he logueado. √ötil para cuando manejo varias cuentas a la vez.

ls


___

https://blog.alcancelibre.org/staticpages/index.php/permisos-sistema-de-archivos

___


para buscar cinco caracteres hay que hacerlo de diferentes maneras en ls que en grep

ls ?????
grep .....

y el asterisco significa diferente

ls ?????*
grep .....*

se supone que estos dos son los errores mas grandes y fijo q algo asi cae en el examen


ls ^???$ ‚Üí esto es INCORRECTO porque no funciona con el ls, el ^ y el $ son para el grep

el -i en el grep es para que no distinga may. y min., pero en el ls son los inodos.

___

find /home: nos va a permitir encontrar o buscar cosas. find + ruta a partir de donde vamos a buscar

find ~ -atime 7: aquellos que fueron accedidos, por ejemplo los que le√≠, desde hace 7 d√≠as; el 7 puede ser otro n√∫mero obviamente. a de accedido.

find ~ -atime -7: los de menos de 7 d√≠as.

find ~ -atime +10: aquellos de m√°s de diez d√≠as.

find ~ -atime 0: en las √∫ltimas 24 horas.

find ~ -mtime 4: modificado en los √∫ltimos 4 d√≠as. m de modificado.

find ~ -name "d*": sigue las mismas reglas que usa el ls. aqu√≠ le pedimos que busque lo que empiece por d. Para que termine por d, "*d".

[NOTE]
Cuando hay un caracter especial como un *, hay que ponerlo entre comillas

find /etc -name "passwd": para buscar nombre del fichero que se llame passwd

find /etc -iname "passwd": sin importar may. y min.

find ~ -iname "passwd" 2>/dev/null: as√≠ no nos da los permisos denegados, los manda a la papelera.

find /etc -user felipe: buscar lo que le pertenece a un usuario.

find /etc -group nombregrupo: buscar lo que pertenece a un grupo de usuarios. Est√° bien a√±adirle el 2>/dev/null.

find . -group asir1 -user asir1 -iname "f*": tiene que cumplir todas las condiciones, que pertenezca al grupo asir1, al usuario asir1 y el nombre del archivo empiece por f. Se tienen que cumplir las tres (AND).

find . -iname "f*" -type f: el type es el tipo de archivo, en este caso es un fichero (f). Se puede poner l (enlace simb√≥lico), 

find . -type f -nouser 2>/dev/null: un fichero que no tenga propietario.
find . -type f -nogroup 2>/dev/null: un fichero que no tenga grupo.

Cuando eliminas un grupo, o usuario...el sistema pone un n√∫mero larg√≠simo al propietario de los archvios que pertenec√≠an a ese grupo o usuario (o queda en blanco), y ahora no tienen grupo o usuario. Por eso hay archivos sin propietario o grupo.

find . -type f -size 4c: un archivo cuyo tama√±o sea 4 caracteres
    4b: 4 bloques
    1G: 1 giga
    1k: 1 kilo

    Puede ser +1k, -1G... igual que el -atime. El = es sin nada.

find . -type f -size +1k -size -10k: para buscar en un rango de tama√±o hay que usar el -size dos veces.

    el -size 0 es igual que usar -empty, buscar un archivo vac√≠o:

find - -type f -empty


find - -type f -executable 2>/dev/null: fichero ordinario que sea ejecutable (que tenga permisos de ejecuci√≥n).

find /var -perm -1000: perm de permisos. Usar sin el -type, para que funcione. No deber√≠an ir juntos. Con un permiso -1000 busco que tenga un sticky bit. Puede ir el numerito con +, con - o sin nada. Los 0s los ignora.

find /var -perm 777: entradas que tengan esos permisos 777, por lo general con 777 son scripts o executables.


___

find . -type f -size -10k -o -empty: el -o es un OR, va a traer los archivos menores de 10k y los vac√≠os.

find . -type f -empty -perm 664: as√≠ es el AND, que est√©n vac√≠os Y tengan permisos 664. As√≠ va a entrar en rutas, si solo quiero que me busque archivos del primer nivel y no entre en todos los subdirectorios, hay que limitar la profundidad, agregando *despu√©s de la ruta* -maxdepth 1.

find . -maxdepth 1 -type f -empty -perm 664: la profundidad OBLIGATORIAMENTE tiene que estar despu√©s de la ruta. Profundidad 1 es el directorio actual.

Si pongo -maxdepth 2 me llegar√° hasta el nivel 2, pero me incluye el 1 y el 2, en caso de que solo quiera el segundo nivel:

find . -mindepth 2 -maxdepth 2 -type f -empty -perm 664: as√≠ afinamos m√°s. Como se dijo antes, la profundidad siempre va despu√©s de la ruta.


find . -maxdepth 1 ! -type f -empty -perm 664: el ! es negaci√≥n, es decir, que no sean ficheros, pueden ser directorios. Solamente niega el tipo. Siempre hay un espacio despu√©s de la !. Si quisiese que afectase a todos, tendr√≠a que poner ! delante de todos.

find . -maxdepth 1 -type f -empty -name "[rR]*"
find . -maxdepth 1 -type f -empty -iname "r*": es lo mismo que lo de arriba, con el iname no discriminar entre may. y min, con el name a secas puedes pedirle que empiece o por r o por R que es lo mismo.

___

find . -maxdepth 1 -type f -empty -name "[rR]*" -exec rm {} \;: despu√©s del -exec siempre va a ir un comando, que es el que queremos que se ejecute. En este caso va a borrar todo lo que est√° entre las llaves, y en este caso es la lista que ha encontrado el find. Tenemos que poner punto y coma para se√±alar donde acaba lo del -exec, pero como por lo general el ; en linea de comandos se usa para separar un comando de otro, hay que escaparlo.

find . -maxdepth 1 -type f -empty -name "[rR]*" -exec chmod 666 {} \; 2>/dev/null: aqu√≠ le pedimos que cambie los permisos a 666 a los arvchivos que encuentre con el find, pero si alguno no te deja cambiarlo que no lo muestre y lo mande al devnull ese.


___

find . -maxdepth 1 -type f -size +0 -name "r*" -exec ls {} \; | head -1: el -size +0 es lo mismo que ! -empty; quiero que me haga un ls de esa b√∫squeda. Y luego le metemos el filtro head -1 para que muestre solo el primero que encontr√≥, es el primero de lo que est√° en las {}.


find . -maxdepth 1 -type f -size +0 -name "r*" -exec head -1 ls {} \;: esto en cambio es diferente al anterior, porque primero hace el head. Va a ejecutar el head tantas veces como ficheros haya encontrado, con la primera linea de cada fichero.


Esto pasa con el head, con el tail...alguno m√°s por ah√≠.
___

find / -maxdepth 1 -links +3 -exec ls -l {} \;: el error m√°s com√∫n es poner link en singular, pero es *links*. Buscar lo que es porque no lo s√©. Creo que pone el n√∫mero de enlaces que tiene cada fichero o algo as√≠. Puede ser +3, -3, 3... con el n√∫mero que sea.

find / -maxdepth 1 -links +3 -exec ls -l {} \; > informe.raiz: as√≠ lo guardamos.

Podemos guardarlo sin erroreS: find / -maxdepth 1 -links +3 -exec ls -l {} \; 2>/dev/null > informe.raiz

[NOTE]
Cuando Rosa pida buscar ficheros no hay que poner el -type f; el -type f hay que ponerlo cuando pida ficheros ORDINARIOS. Esto es por lo de que para Linux todo eran ficheros.

[NOTE]
El enlace duro si lo queremos buscar es un -type f, a diferencia del enlace blando que es -type l

___

alias
Nombres que le ponemos a algo, para no olvidarnos, por ejemplo, en vez de estar todo el rato poniendo _clear_, me creo un alias m√°s corto y lo uso cuando quiera ejecutarlo.

alias c="clear"

Una vez cierre la consola, cuando vuelva a abrirla ya no estar√°n, se habr√°n borrado.

Existen ya unois alias predefinidos por Ubuntu, cuando hacemos un less ~/.bashrc se pueden ver, casi al final, algunos. Por ejemplo, hay un alias _la_ para el comando _ls-A_.

Si editamos este fichero y a√±adimos nuestros alias personalizados, s√≠ que quedar√°n permanentemente guardados. Si no quiero utilizar alguno, o bien lo elimino, o bien lo comento con # (es lo m√°s sensato).
Habr√° que reiniciar la terminal porque el fichero .bashrc se carga al abrir la terminal.

=== alias contar="echo Hay `ls | wc -l` entradas en mi directorio `pwd`"
Lo que va entre `` ser√≠a como una variable. Es el acento de la derecha de la P.


== unalias contar
Eliminar el alias. Se elimina el de memoria, si lo creamos editando el archivo .bashrc no se eliminar√≠a con este comando, habr√≠a que ir al archivo para eliminarlo.

== alias vs="pwd; id; echo hola"
Se puede guardar un alias con comandos concatenados. Nos har√≠a los tres comandos al ejecutar el alias.

___

Variables de usuario

== nombre="Felipe"
Se declara una variable.

== echo $nombre
Visualizamos el nombre de la variable.

Puede usarse un echo con el texto que sea y meterle las variables que quieras por medio.

=== echo Me llamo $nombre y mi pc es el `tty`
Aqu√≠ usamos tanto variable como comando tty para que nos diga el nombre y el pc que usamos.

=== a=`pwd`
Guardamos una variable con un comando. Cuando invoquemos la variable va a ejecutar ese comando.

=== echo \$a = $a
A veces necesitaremos escapar el $ para que no lo tome como variable.


=== a=
As√≠ no se borra la variable, as√≠ ahora la variable va a estar vac√≠a, pero seguir√° estando en memoria

=== unset a
As√≠ s√≠, la variable queda borrada.

___

Variables de entorno

== set | less
ves variables de entorno y scripts


== env | less
Este solo las variables de entorno; env de enviroment.

A diferencia de las variables del usuario, las variables del sistema est√°n en may√∫sculas. 

== echo $HOME
Nos mostrar√≠a nuestro home.

== set | grep ^HOME
Buscar la variable HOME.

== env | grep ^HOME
Buscar la variable HOME tambi√©n.

== echo $MAIL


== echo $USER
Saber cu√°l es mi usuario.

== echo $PATH
Esta a veces la cambiamos nosotros.

== echo $PS1
Todo lo que sale es el prompt, pero con codificaciones de color, letra...
Aqu√≠ se guarda la configuraci√≥n de nuestro prompt. 

---
Ver el documento de las variables de entorno del aula virtual.
---

== echo `ls`

== echo -e Estoy utilizando el shell $SHELL\n en la versi√≥n $BASH_VERSION
El -e se tiene que poner en el echo para que interprete los escapes \
En este caso quiero hacer un salto de l√≠nea con \n, por lo que el -e es necesario.

== echo Hola "*"
Si en cualquier parte del texto del echo hay que poner un *, hay que meterlo entre comillas. Puede ponerse tambi√©n "Hola *", pero el * entre las comillas.

== echo $LOGNAME
Es lo mismo que el comando logname. Hace exactamente lo mismo.

== hostname
este comando tiene tambi√©n una variable de entorno que hace lo mismo: $HOSTNAME

== echo $OLDPWD
Me dice el √∫ltimo directorio donde estuve.


== cd $OLDPWD
Te manda al √∫ltimo directorio donde estuve.

=== cd $OLDPWD && touch fichero.txt
Que se vaya al √∫ltimo directorio donde estuve y cree un fichero; si la primera parte no la puede hacer, la segunda tampoco la hace. El segundo comando es dependiente del primero. El && es un AND, se tiene que cumplir la primera para ejecutarse la segunda.

Si lo que no puede hacer es la segunda parte, la primera s√≠ que la hace igualmente.

== echo Hola || echo Adios
El || es un OR, o se cumple la primera o se cumple la segunda.
Si la primera se ejecuta, la segunda ya no se ejecuta; si no se cumple la primera, se cumplir√° la segunda si puede hacer. Si no pues ninguna xd.

[NOTE]
A estos dos anteriores se les llama comandos en cortocircuito.

___

== whereis passwd
Sirve para ubicar d√≥nde est√° un comando.

== apropos date
En qu√© lugares del manual se menciona este comando (se menciona como comando o como palabra).

== stat ejer4
El estado completo, informaci√≥n, sobre un fichero: tama√±o, bloques, d√≥nde est√°, inodo, enlaces, acceso, permisos (octal/simb√≥lico), propietario (n¬∫/nombre), grupo, √∫ltimo acceso, √∫ltima modificaci√≥n, cambio, creaci√≥n...

=== stat Documentos/
El estado de un directorio; nos dir√° que es un fichero de tipo directorio y por lo dem√°s es lo mismo que hacer un stat a un fichero ordinario.

=== stat * | less
El less es solo porque como va a ser largo es mejor paginarlo. Va a hacerle el stat a todos los archivos.






















